//! # Faux
//!
//! A library to create
//! [mocks](https://en.wikipedia.org/wiki/Mock_object) out of
//! `struct`s.
//!
//! `faux` provides macros to help you create mocks out of your
//! structs without creating traits and using generics/trait objects.
//!
//! **`faux` makes liberal use of unsafe rust features, and it is not
//! recommended for use outside of tests.**
//!
//! ## Usage:
//! ```edition2018
//! // creates the mockable struct
//! #[faux::create]
//! pub struct Foo {
//!     a: u32,
//! }
//!
//! // mocks the methods
//! #[faux::methods]
//! impl Foo {
//!     pub fn new(a: u32) -> Self {
//!         Foo { a }
//!     }
//!
//!     pub fn get_stuff(&self) -> u32 {
//!         self.a
//!     }
//! }
//!
//! fn main() {
//!   // `faux` will not override making the real version of your struct
//!   let real = Foo::new(3);
//!   assert_eq!(real.get_stuff(), 3);
//!
//!   // while providing a method to create a mock
//!   let mut mock = Foo::faux();
//!   unsafe { faux::when!(mock.get_stuff).then(|_| 10) }
//!   assert_eq!(mock.get_stuff(), 10);
//! }
//! ```

mod when;

use proc_macro_hack::proc_macro_hack;
use std::{
    any::{Any, TypeId},
    cell::RefCell,
    collections::HashMap,
};

/// Creates a mockable struct
pub use faux_macros::create;

/// Creates mockable methods inside an impl block
pub use faux_macros::methods;

/// Creates a [When](When) for a specific instance/method pair
///
/// This macro is a wrapper around calling the `_when_{method_name}`
/// method that was auto-generated by the [methods](attr.methods.html)
/// attribute.
///
/// ```ignore
/// // these two are functionally equal
/// when!(x.my_method).then(/*..*/)
/// x._when_my_method().then(/*..*/)
/// ```
#[proc_macro_hack]
pub use faux_macros::when;

pub use when::When;

#[doc(hidden)]
pub enum MaybeFaux<T> {
    Real(T),
    Faux(RefCell<Faux>),
}

impl<T> MaybeFaux<T> {
    pub fn faux() -> Self {
        MaybeFaux::Faux(RefCell::new(Faux::default()))
    }
}

/// Fake struct storing the mocked methods
#[derive(Default)]
pub struct Faux {
    mocks: HashMap<TypeId, Mock>,
}

#[doc(hidden)]
impl Faux {
    /// # Safety
    /// Do not use this function without going through [When](When).
    pub unsafe fn unsafe_mock_once<I, O>(&mut self, id: TypeId, mock: impl FnOnce(I) -> O) {
        self.mocks.insert(id, Mock::r#unsafe(mock));
    }

    pub fn mock_once<I, O>(&mut self, id: TypeId, mock: impl FnOnce(I) -> O + 'static)
    where
        I: 'static,
        O: 'static,
    {
        self.mocks.insert(id, Mock::safe(mock));
    }

    pub fn get_mock(&mut self, id: TypeId) -> Option<Mock> {
        self.mocks.remove(&id)
    }
}

#[doc(hidden)]
pub enum Mock {
    OnceUnsafe(UnsafeMock),
    OnceSafe(SafeMock),
}

impl Mock {
    fn safe<I: 'static, O: 'static>(mock: impl FnOnce(I) -> O + 'static) -> Self {
        let mock = |input: Box<dyn Any>| {
            let input = *(input.downcast().unwrap());
            let output = mock(input);
            Box::new(output) as Box<dyn Any>
        };
        Mock::OnceSafe(SafeMock(Box::new(mock)))
    }

    unsafe fn r#unsafe<I, O>(mock: impl FnOnce(I) -> O) -> Self {
        let mock = Box::new(mock) as Box<dyn FnOnce(_) -> _>;
        let mock = std::mem::transmute(mock);
        Mock::OnceUnsafe(UnsafeMock(mock))
    }
}

#[doc(hidden)]
pub struct SafeMock(Box<dyn FnOnce(Box<dyn Any>) -> Box<dyn Any>>);

impl SafeMock {
    pub fn call<I: 'static, O: 'static>(self, input: I) -> O {
        let input = Box::new(input) as Box<dyn Any>;
        *self.0(input).downcast().unwrap()
    }
}

#[doc(hidden)]
pub struct UnsafeMock(Box<dyn FnOnce(()) -> ()>);

impl UnsafeMock {
    pub unsafe fn call<I, O>(self, input: I) -> O {
        let mock: Box<dyn FnOnce(I) -> O> = std::mem::transmute(self.0);
        mock(input)
    }
}
